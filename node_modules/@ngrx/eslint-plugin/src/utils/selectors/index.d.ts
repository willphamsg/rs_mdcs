export declare const effectCreator = "PropertyDefinition[value.callee.name='createEffect']";
export declare const createEffectExpression = "CallExpression[callee.name='createEffect']";
export declare const effectDecorator = "Decorator[expression.callee.name='Effect']";
export declare const propertyDefinitionWithEffectDecorator: "ClassDeclaration > ClassBody > PropertyDefinition > Decorator[expression.callee.name='Effect']";
export declare const actionCreator = "CallExpression[callee.name='createAction']";
export declare const actionCreatorWithLiteral: "CallExpression[callee.name='createAction'][arguments.0.type='Literal'][arguments.0.raw=/^'/]";
export declare const actionCreatorProps: "CallExpression[callee.name='createAction'] > CallExpression[callee.name='props']";
export declare const actionCreatorPropsComputed: "CallExpression[callee.name='createAction'] > CallExpression[callee.name='props'] > TSTypeParameterInstantiation > :matches(TSTypeReference[typeName.name!='Readonly'], [type=/^TS(.*)(Keyword|Type)$/])";
export declare const constructorDefinition = "MethodDefinition[kind='constructor']";
export declare function metadataProperty(key: RegExp): string;
export declare function metadataProperty<TKey extends string>(key: TKey): `Property:matches([key.name=${TKey}][computed=false], [key.value=${TKey}], [key.quasis.0.value.raw=${TKey}])`;
export declare const ngModuleDecorator = "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule']";
export declare const ngModuleImports: "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule'] ObjectExpression Property:matches([key.name=imports][computed=false], [key.value=imports], [key.quasis.0.value.raw=imports]) > ArrayExpression";
export declare const ngModuleProviders: "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule'] ObjectExpression Property:matches([key.name=providers][computed=false], [key.value=providers], [key.quasis.0.value.raw=providers]) > ArrayExpression";
export declare const effectsInNgModuleImports: "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule'] ObjectExpression Property:matches([key.name=imports][computed=false], [key.value=imports], [key.quasis.0.value.raw=imports]) > ArrayExpression CallExpression[callee.object.name='EffectsModule'][callee.property.name=/^for(Root|Feature)$/] ArrayExpression > Identifier";
export declare const effectsInNgModuleProviders: "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule'] ObjectExpression Property:matches([key.name=providers][computed=false], [key.value=providers], [key.quasis.0.value.raw=providers]) > ArrayExpression Identifier";
export declare const namedExpression: (name: RegExp | string) => `:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])`;
export declare const namedCallableExpression: (name: RegExp | string) => `:matches(:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}]), MethodDefinition[kind='constructor'] CallExpression[callee.object.callee.object.name=${string}], CallExpression[callee.object.callee.object.object.type='ThisExpression'][callee.object.callee.object.property.name=${string}])`;
export declare const pipeExpression: (name: RegExp | string) => `:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])[callee.property.name='pipe']`;
export declare const pipeableSelect: (name: RegExp | string) => `:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])[callee.property.name='pipe'] CallExpression[callee.name='select']`;
export declare const selectExpression: (name: RegExp | string) => `:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])[callee.property.name='select']`;
export declare const dispatchExpression: (name: RegExp | string) => `:matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])[callee.property.name='dispatch']`;
export declare const dispatchInEffects: (name: RegExp | string) => `CallExpression[callee.name='createEffect'] :matches(MethodDefinition[kind='constructor'] CallExpression[callee.object.name=${string}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${string}])[callee.property.name='dispatch'] > MemberExpression:has(Identifier[name=${string}])`;
export declare const createReducer = "CallExpression[callee.name='createReducer']";
export declare const onFunctionWithoutType: "CallExpression[callee.name='createReducer'] CallExpression[callee.name='on'] > ArrowFunctionExpression:not([returnType.typeAnnotation])";
export declare const storeActionReducerMap: "ClassDeclaration > Decorator > CallExpression[callee.name='NgModule'] ObjectExpression Property:matches([key.name=imports][computed=false], [key.value=imports], [key.quasis.0.value.raw=imports]) > ArrayExpression CallExpression[callee.object.name='StoreModule'][callee.property.name=/^for(Root|Feature)$/] > ObjectExpression:first-child";
export declare const actionReducerMap = "VariableDeclarator[id.typeAnnotation.typeAnnotation.typeName.name='ActionReducerMap'] > ObjectExpression";
export declare const mapLikeOperatorCallExpressions: ":matches(CallExpression[callee.name=/^(concat|merge|switch)MapTo$/], CallExpression[callee.name=/^(concat|exhaust|flat|merge|switch)Map$/] > :matches(ReturnStatement,ArrowFunctionExpression,FunctionExpression))";
