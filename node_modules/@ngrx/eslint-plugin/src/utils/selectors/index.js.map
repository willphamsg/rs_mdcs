{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/utils/selectors/index.ts"],"names":[],"mappings":";;;AAqBA,4CAEC;AAvBY,QAAA,aAAa,GAAG,sDAAsD,CAAC;AACvE,QAAA,sBAAsB,GAAG,4CAA4C,CAAC;AAEtE,QAAA,eAAe,GAAG,4CAA4C,CAAC;AAC/D,QAAA,qCAAqC,GAChD,uDAAuD,uBAAe,EAAW,CAAC;AAEvE,QAAA,aAAa,GAAG,4CAA4C,CAAC;AAC7D,QAAA,wBAAwB,GACnC,GAAG,qBAAa,oDAA6D,CAAC;AACnE,QAAA,kBAAkB,GAC7B,GAAG,qBAAa,wCAAiD,CAAC;AACvD,QAAA,0BAA0B,GACrC,GAAG,0BAAkB,yHAAkI,CAAC;AAE7I,QAAA,qBAAqB,GAAG,sCAAsC,CAAC;AAM5E,SAAgB,gBAAgB,CAAC,GAAoB;IACnD,OAAO,8BAA8B,GAAG,iCAAiC,GAAG,8BAA8B,GAAG,IAAI,CAAC;AACpH,CAAC;AAEY,QAAA,iBAAiB,GAAG,uEAAuE,CAAC;AAE5F,QAAA,eAAe,GAC1B,GAAG,yBAAiB,qBAAqB,gBAAgB,CACvD,SAAS,CACV,oBAA6B,CAAC;AAEpB,QAAA,iBAAiB,GAC5B,GAAG,yBAAiB,qBAAqB,gBAAgB,CACvD,WAAW,CACZ,oBAA6B,CAAC;AAEpB,QAAA,wBAAwB,GACnC,GAAG,uBAAe,8HAAuI,CAAC;AAE/I,QAAA,0BAA0B,GACrC,GAAG,yBAAiB,aAAsB,CAAC;AAEtC,MAAM,eAAe,GAAG,CAAC,IAAqB,EAAE,EAAE,CACvD,YAAY,6BAAqB,sCAAsC,IAAI,6FAA6F,IAAI,IAAa,CAAC;AAD/K,QAAA,eAAe,mBACgK;AAErL,MAAM,uBAAuB,GAAG,CAAC,IAAqB,EAAE,EAAE,CAC/D,YAAY,IAAA,uBAAe,EACzB,IAAI,CACL,KAAK,6BAAqB,oDAAoD,IAAI,yHAAyH,IAAI,IAAa,CAAC;AAHnN,QAAA,uBAAuB,2BAG4L;AAEzN,MAAM,cAAc,GAAG,CAAC,IAAqB,EAAE,EAAE,CACtD,GAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,+BAAwC,CAAC;AADtD,QAAA,cAAc,kBACwC;AAE5D,MAAM,cAAc,GAAG,CAAC,IAAqB,EAAE,EAAE,CACtD,GAAG,IAAA,sBAAc,EAAC,IAAI,CAAC,uCAAgD,CAAC;AAD7D,QAAA,cAAc,kBAC+C;AAEnE,MAAM,gBAAgB,GAAG,CAAC,IAAqB,EAAE,EAAE,CACxD,GAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,iCAA0C,CAAC;AADxD,QAAA,gBAAgB,oBACwC;AAE9D,MAAM,kBAAkB,GAAG,CAAC,IAAqB,EAAE,EAAE,CAC1D,GAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,mCAA4C,CAAC;AAD1D,QAAA,kBAAkB,sBACwC;AAEhE,MAAM,iBAAiB,GAAG,CAAC,IAAqB,EAAE,EAAE,CACzD,GAAG,8BAAsB,IAAI,IAAA,0BAAkB,EAC7C,IAAI,CACL,2CAA2C,IAAI,IAAa,CAAC;AAHnD,QAAA,iBAAiB,qBAGkC;AAEnD,QAAA,aAAa,GAAG,6CAA6C,CAAC;AAE9D,QAAA,qBAAqB,GAChC,GAAG,qBAAa,8FAAuG,CAAC;AAE7G,QAAA,qBAAqB,GAChC,GAAG,uBAAe,8HAAuI,CAAC;AAE/I,QAAA,gBAAgB,GAAG,0GAA0G,CAAC;AAE3I,MAAM,gBAAgB,GAAG,2CAA2C,CAAC;AACrE,MAAM,kBAAkB,GAAG,gCAAgC,CAAC;AAC/C,QAAA,8BAA8B,GACzC,uCAAuC,kBAAkB,iCAAiC,gBAAgB,2EAAoF,CAAC","sourcesContent":["export const effectCreator = `PropertyDefinition[value.callee.name='createEffect']`;\nexport const createEffectExpression = `CallExpression[callee.name='createEffect']`;\n\nexport const effectDecorator = `Decorator[expression.callee.name='Effect']`;\nexport const propertyDefinitionWithEffectDecorator =\n  `ClassDeclaration > ClassBody > PropertyDefinition > ${effectDecorator}` as const;\n\nexport const actionCreator = `CallExpression[callee.name='createAction']`;\nexport const actionCreatorWithLiteral =\n  `${actionCreator}[arguments.0.type='Literal'][arguments.0.raw=/^'/]` as const;\nexport const actionCreatorProps =\n  `${actionCreator} > CallExpression[callee.name='props']` as const;\nexport const actionCreatorPropsComputed =\n  `${actionCreatorProps} > TSTypeParameterInstantiation > :matches(TSTypeReference[typeName.name!='Readonly'], [type=/^TS(.*)(Keyword|Type)$/])` as const;\n\nexport const constructorDefinition = `MethodDefinition[kind='constructor']`;\n\nexport function metadataProperty(key: RegExp): string;\nexport function metadataProperty<TKey extends string>(\n  key: TKey\n): `Property:matches([key.name=${TKey}][computed=false], [key.value=${TKey}], [key.quasis.0.value.raw=${TKey}])`;\nexport function metadataProperty(key: RegExp | string): string {\n  return `Property:matches([key.name=${key}][computed=false], [key.value=${key}], [key.quasis.0.value.raw=${key}])`;\n}\n\nexport const ngModuleDecorator = `ClassDeclaration > Decorator > CallExpression[callee.name='NgModule']`;\n\nexport const ngModuleImports =\n  `${ngModuleDecorator} ObjectExpression ${metadataProperty(\n    'imports'\n  )} > ArrayExpression` as const;\n\nexport const ngModuleProviders =\n  `${ngModuleDecorator} ObjectExpression ${metadataProperty(\n    'providers'\n  )} > ArrayExpression` as const;\n\nexport const effectsInNgModuleImports =\n  `${ngModuleImports} CallExpression[callee.object.name='EffectsModule'][callee.property.name=/^for(Root|Feature)$/] ArrayExpression > Identifier` as const;\n\nexport const effectsInNgModuleProviders =\n  `${ngModuleProviders} Identifier` as const;\n\nexport const namedExpression = (name: RegExp | string) =>\n  `:matches(${constructorDefinition} CallExpression[callee.object.name=${name}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${name}])` as const;\n\nexport const namedCallableExpression = (name: RegExp | string) =>\n  `:matches(${namedExpression(\n    name\n  )}, ${constructorDefinition} CallExpression[callee.object.callee.object.name=${name}], CallExpression[callee.object.callee.object.object.type='ThisExpression'][callee.object.callee.object.property.name=${name}])` as const;\n\nexport const pipeExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='pipe']` as const;\n\nexport const pipeableSelect = (name: RegExp | string) =>\n  `${pipeExpression(name)} CallExpression[callee.name='select']` as const;\n\nexport const selectExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='select']` as const;\n\nexport const dispatchExpression = (name: RegExp | string) =>\n  `${namedExpression(name)}[callee.property.name='dispatch']` as const;\n\nexport const dispatchInEffects = (name: RegExp | string) =>\n  `${createEffectExpression} ${dispatchExpression(\n    name\n  )} > MemberExpression:has(Identifier[name=${name}])` as const;\n\nexport const createReducer = `CallExpression[callee.name='createReducer']`;\n\nexport const onFunctionWithoutType =\n  `${createReducer} CallExpression[callee.name='on'] > ArrowFunctionExpression:not([returnType.typeAnnotation])` as const;\n\nexport const storeActionReducerMap =\n  `${ngModuleImports} CallExpression[callee.object.name='StoreModule'][callee.property.name=/^for(Root|Feature)$/] > ObjectExpression:first-child` as const;\n\nexport const actionReducerMap = `VariableDeclarator[id.typeAnnotation.typeAnnotation.typeName.name='ActionReducerMap'] > ObjectExpression`;\n\nconst mapLikeOperators = '/^(concat|exhaust|flat|merge|switch)Map$/';\nconst mapLikeToOperators = '/^(concat|merge|switch)MapTo$/';\nexport const mapLikeOperatorCallExpressions =\n  `:matches(CallExpression[callee.name=${mapLikeToOperators}], CallExpression[callee.name=${mapLikeOperators}] > :matches(ReturnStatement,ArrowFunctionExpression,FunctionExpression))` as const;\n"]}