{"version":3,"file":"select-style.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/rules/store/select-style.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2CAA6B;AAC7B,qDAAgD;AAChD,uCAYqB;AAER,QAAA,YAAY,GAAG,cAAc,CAAC;AAC9B,QAAA,cAAc,GAAG,gBAAgB,CAAC;AAE/C,IAAkB,WAGjB;AAHD,WAAkB,WAAW;IAC3B,gCAAiB,CAAA;IACjB,oCAAqB,CAAA;AACvB,CAAC,EAHiB,WAAW,2BAAX,WAAW,QAG5B;AAmBD,kBAAe,IAAA,yBAAU,EAAsB;IAC7C,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI;IACjC,IAAI,EAAE;QACJ,IAAI,EAAE,YAAY;QAClB,IAAI,EAAE;YACJ,WAAW,EACT,kFAAkF;YACpF,UAAU,EAAE,OAAO;SACpB;QACD,OAAO,EAAE,MAAM;QACf,MAAM,EAAE;YACN;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,CAAC,WAAW,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,CAAC;aACjD;SACF;QACD,QAAQ,EAAE;YACR,CAAC,WAAW,CAAC,MAAM,CAAC,EAClB,4EAA4E;YAC9E,CAAC,WAAW,CAAC,QAAQ,CAAC,EACpB,0FAA0F;SAC7F;KACF;IACD,cAAc,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC;IACpC,MAAM,EAAE,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE,EAAE;QAC1B,MAAM,EAAE,WAAW,GAAG,EAAE,EAAE,UAAU,EAAE,GAAG,IAAA,qBAAa,EAAC,OAAO,CAAC,CAAC;QAChE,MAAM,UAAU,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAA,iBAAS,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAE1E,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,IAAI,IAAI,KAAK,WAAW,CAAC,QAAQ,EAAE,CAAC;YAClC,OAAO;gBACL,CAAC,IAAA,wBAAgB,EAAC,UAAU,CAAC,CAAC,CAAC,IAAoB;oBACjD,OAAO,CAAC,MAAM,CAAC;wBACb,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ;wBAC1B,SAAS,EAAE,WAAW,CAAC,QAAQ;wBAC/B,GAAG,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,wBAAwB,CAAC,IAAI,EAAE,KAAK,CAAC;qBACtD,CAAC,CAAC;gBACL,CAAC;aACF,CAAC;QACJ,CAAC;QAED,OAAO;YACL,CAAC,eAAe,IAAA,sBAAc,EAC5B,UAAU,CACX,qCACC,yBAAiB,CAAC,KACpB,8CAA8C,CAAC,CAC7C,IAEC;gBAED,OAAO,CAAC,MAAM,CAAC;oBACb,IAAI;oBACJ,SAAS,EAAE,WAAW,CAAC,MAAM;oBAC7B,GAAG,EAAE,CAAC,KAAK,EAAE,EAAE,CACb,IAAA,0BAAkB,EAAC,UAAU,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC;iBACjE,CAAC,CAAC;gBAEH,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC,GAAG,UAAU,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAE/D,KAAK,MAAM,EAAE,UAAU,EAAE,IAAI,UAAU,EAAE,CAAC;oBACxC,OAAO,CAAC,MAAM,CAAC;wBACb,IAAI,EAAE,UAAU;wBAChB,SAAS,EAAE,WAAW,CAAC,MAAM;wBAC7B,GAAG,EAAE,CAAC,KAAK,EAAE,EAAE,CACb,wBAAwB,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,CAAC;qBAC1D,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;SACF,CAAC;IACJ,CAAC;CACF,CAAC,CAAC;AAEH,SAAS,wBAAwB,CAC/B,IAAoB,EACpB,KAAyB;IAEzB,MAAM,gBAAgB,GAAG,IAAA,+BAAuB,EAAC,IAAI,EAAE,0BAAkB,CAAC,CAAC;IAE3E,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACtB,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,OAAO;QACL,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC;QACrD,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,GAAG,CAAC;KACjC,CAAC,MAAM,CACN,IAAA,uBAAe,EAAC;QACd,KAAK;QACL,UAAU,EAAE,QAAQ;QACpB,UAAU,EAAE,yBAAiB,CAAC,KAAK;QACnC,IAAI,EAAE,gBAAgB;KACvB,CAAC,CACH,CAAC;AACJ,CAAC;AAED,SAAS,wBAAwB,CAC/B,UAAyB,EACzB,UAAyC,EACzC,KAAyB;IAEzB,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;IACjC,MAAM,SAAS,GAAG,MAAM,EAAE,MAAM,CAAC;IAEjC,IACE,CAAC,SAAS;QACV,CAAC,IAAA,wBAAgB,EAAC,SAAS,CAAC;QAC5B,CAAC,IAAA,0BAAkB,EAAC,SAAS,CAAC,MAAM,CAAC,EACrC,CAAC;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,sBAAsB,GAAG,SAAS,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC;IAEhE,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC5B,MAAM,aAAa,GAAG,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACjD,MAAM,oBAAoB,GAAG,UAAU,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAC9D,MAAM,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC;QACtC,OAAO;YACL,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;YACpB,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YACrE,KAAK,CAAC,eAAe,CAAC,KAAK,EAAE,IAAI,aAAa,EAAE,CAAC;SAClD,CAAC;IACJ,CAAC;IAED,MAAM,EAAE,QAAQ,EAAE,GAAG,SAAS,CAAC,MAAM,CAAC;IACtC,MAAM,kBAAkB,GAAG,UAAU,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;IAC9D,MAAM,CAAC,gBAAgB,EAAE,YAAY,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC;IACxD,MAAM,SAAS,GAAmB;QAChC,gBAAgB;QAChB,kBAAkB,EAAE,KAAK,CAAC,CAAC,CAAC,IAAI,YAAY;KAC7C,CAAC;IACF,MAAM,CAAC,EAAE,cAAc,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC;IAC5C,OAAO;QACL,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC;QAC5B,KAAK,CAAC,oBAAoB,CAAC,CAAC,cAAc,EAAE,cAAc,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;KACtE,CAAC;AACJ,CAAC","sourcesContent":["import type { TSESLint, TSESTree } from '@typescript-eslint/utils';\nimport * as path from 'path';\nimport { createRule } from '../../rule-creator';\nimport {\n  asPattern,\n  getImportAddFix,\n  getImportRemoveFix,\n  getNearestUpperNodeFrom,\n  getNgRxStores,\n  isCallExpression,\n  isClassDeclaration,\n  isMemberExpression,\n  NGRX_MODULE_PATHS,\n  pipeableSelect,\n  selectExpression,\n} from '../../utils';\n\nexport const selectMethod = 'selectMethod';\nexport const selectOperator = 'selectOperator';\n\nexport const enum SelectStyle {\n  Method = 'method',\n  Operator = 'operator',\n}\n\ntype MessageIds = `${SelectStyle}`;\ntype Options = readonly [MessageIds];\ntype MemberExpressionWithProperty = Omit<\n  TSESTree.MemberExpression,\n  'property'\n> & {\n  property: TSESTree.Identifier;\n};\ntype CallExpression = Omit<TSESTree.CallExpression, 'parent'> & {\n  callee: MemberExpressionWithProperty;\n  parent: TSESTree.CallExpression & {\n    callee: Omit<TSESTree.MemberExpression, 'object'> & {\n      object: MemberExpressionWithProperty;\n    };\n  };\n};\n\nexport default createRule<Options, MessageIds>({\n  name: path.parse(__filename).name,\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description:\n        'Selector can be used either with `select` as a pipeable operator or as a method.',\n      ngrxModule: 'store',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        type: 'string',\n        enum: [SelectStyle.Method, SelectStyle.Operator],\n      },\n    ],\n    messages: {\n      [SelectStyle.Method]:\n        'Selector should be used with select method: `this.store.select(selector)`.',\n      [SelectStyle.Operator]:\n        'Selector should be used with the pipeable operator: `this.store.pipe(select(selector))`.',\n    },\n  },\n  defaultOptions: [SelectStyle.Method],\n  create: (context, [mode]) => {\n    const { identifiers = [], sourceCode } = getNgRxStores(context);\n    const storeNames = identifiers.length > 0 ? asPattern(identifiers) : null;\n\n    if (!storeNames) {\n      return {};\n    }\n\n    if (mode === SelectStyle.Operator) {\n      return {\n        [selectExpression(storeNames)](node: CallExpression) {\n          context.report({\n            node: node.callee.property,\n            messageId: SelectStyle.Operator,\n            fix: (fixer) => getMethodToOperatorFixes(node, fixer),\n          });\n        },\n      };\n    }\n\n    return {\n      [`Program:has(${pipeableSelect(\n        storeNames\n      )}) ImportDeclaration[source.value='${\n        NGRX_MODULE_PATHS.store\n      }'] > ImportSpecifier[imported.name='select']`](\n        node: TSESTree.ImportSpecifier & {\n          parent: TSESTree.ImportDeclaration;\n        }\n      ) {\n        context.report({\n          node,\n          messageId: SelectStyle.Method,\n          fix: (fixer) =>\n            getImportRemoveFix(sourceCode, [node.parent], 'select', fixer),\n        });\n\n        const [{ references }] = sourceCode.getDeclaredVariables(node);\n\n        for (const { identifier } of references) {\n          context.report({\n            node: identifier,\n            messageId: SelectStyle.Method,\n            fix: (fixer) =>\n              getOperatorToMethodFixes(identifier, sourceCode, fixer),\n          });\n        }\n      },\n    };\n  },\n});\n\nfunction getMethodToOperatorFixes(\n  node: CallExpression,\n  fixer: TSESLint.RuleFixer\n): readonly TSESLint.RuleFix[] {\n  const classDeclaration = getNearestUpperNodeFrom(node, isClassDeclaration);\n\n  if (!classDeclaration) {\n    return [];\n  }\n\n  return [\n    fixer.insertTextBefore(node.callee.property, 'pipe('),\n    fixer.insertTextAfter(node, ')'),\n  ].concat(\n    getImportAddFix({\n      fixer,\n      importName: 'select',\n      moduleName: NGRX_MODULE_PATHS.store,\n      node: classDeclaration,\n    })\n  );\n}\n\nfunction getOperatorToMethodFixes(\n  identifier: TSESTree.Node,\n  sourceCode: Readonly<TSESLint.SourceCode>,\n  fixer: TSESLint.RuleFixer\n): readonly TSESLint.RuleFix[] {\n  const select = identifier.parent;\n  const storePipe = select?.parent;\n\n  if (\n    !storePipe ||\n    !isCallExpression(storePipe) ||\n    !isMemberExpression(storePipe.callee)\n  ) {\n    return [];\n  }\n\n  const pipeContainsOnlySelect = storePipe.arguments.length === 1;\n\n  if (!pipeContainsOnlySelect) {\n    const selectContent = sourceCode.getText(select);\n    const nextTokenAfterSelect = sourceCode.getTokenAfter(select);\n    const store = storePipe.callee.object;\n    return [\n      fixer.remove(select),\n      ...(nextTokenAfterSelect ? [fixer.remove(nextTokenAfterSelect)] : []),\n      fixer.insertTextAfter(store, `.${selectContent}`),\n    ];\n  }\n\n  const { property } = storePipe.callee;\n  const nextTokenAfterPipe = sourceCode.getTokenAfter(property);\n  const [pipeInitialRange, pipeEndRange] = property.range;\n  const pipeRange: TSESTree.Range = [\n    pipeInitialRange,\n    nextTokenAfterPipe?.range[1] ?? pipeEndRange,\n  ];\n  const [, selectEndRange] = identifier.range;\n  return [\n    fixer.removeRange(pipeRange),\n    fixer.insertTextAfterRange([selectEndRange, selectEndRange + 1], '('),\n  ];\n}\n"]}