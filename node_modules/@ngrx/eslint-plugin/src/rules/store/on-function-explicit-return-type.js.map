{"version":3,"file":"on-function-explicit-return-type.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/rules/store/on-function-explicit-return-type.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,oDAAoD;AACpD,2CAA6B;AAC7B,qDAAgD;AAChD,uCAA6D;AAEhD,QAAA,4BAA4B,GAAG,8BAA8B,CAAC;AAC9D,QAAA,mCAAmC,GAC9C,qCAAqC,CAAC;AAOxC,kBAAe,IAAA,yBAAU,EAAsB;IAC7C,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI;IACjC,IAAI,EAAE;QACJ,IAAI,EAAE,YAAY;QAClB,cAAc,EAAE,IAAI;QACpB,IAAI,EAAE;YACJ,WAAW,EAAE,oDAAoD;YACjE,UAAU,EAAE,OAAO;SACpB;QACD,MAAM,EAAE,EAAE;QACV,QAAQ,EAAE;YACR,CAAC,oCAA4B,CAAC,EAC5B,mHAAmH;YACrH,CAAC,2CAAmC,CAAC,EACnC,iIAAiI;SACpI;KACF;IACD,cAAc,EAAE,EAAE;IAClB,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE;QAClB,OAAO;YACL,CAAC,6BAAqB,CAAC,CAAC,IAAsC;gBAC5D,OAAO,CAAC,MAAM,CAAC;oBACb,IAAI;oBACJ,SAAS,EAAE,oCAA4B;oBACvC,OAAO,EAAE;wBACP;4BACE,SAAS,EAAE,2CAAmC;4BAC9C,GAAG,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC;yBAC1D;qBACF;iBACF,CAAC,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;CACF,CAAC,CAAC;AAEH,SAAS,QAAQ,CACf,IAAsC,EACtC,UAAyC,EACzC,KAAyB;IAEzB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC;IAExB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,MAAM,CAAC,EAAE,YAAY,CAAC,GAAG,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACpD,OAAO,KAAK,CAAC,eAAe,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;IACxD,CAAC;IAED,MAAM,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC;IAC5B,MAAM,SAAS,GAAG,IAAA,eAAO,EAAC,MAAM,CAAC,CAAC;IAClC,MAAM,aAAa,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IAC5D,MAAM,eAAe,GACnB,aAAa,IAAI,gBAAQ,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;IAE/D,IAAI,eAAe,EAAE,CAAC;QACpB,MAAM,SAAS,GAAG,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;QACtD,OAAO,KAAK,CAAC,eAAe,CAAC,SAAS,IAAI,SAAS,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;IAED,OAAO;QACL,KAAK,CAAC,gBAAgB,CAAC,UAAU,EAAE,GAAG,CAAC;QACvC,KAAK,CAAC,eAAe,CAAC,SAAS,EAAE,UAAU,CAAC;KACpC,CAAC;AACb,CAAC","sourcesContent":["import type { TSESLint, TSESTree } from '@typescript-eslint/utils';\nimport { ASTUtils } from '@typescript-eslint/utils';\nimport * as path from 'path';\nimport { createRule } from '../../rule-creator';\nimport { getLast, onFunctionWithoutType } from '../../utils';\n\nexport const onFunctionExplicitReturnType = 'onFunctionExplicitReturnType';\nexport const onFunctionExplicitReturnTypeSuggest =\n  'onFunctionExplicitReturnTypeSuggest';\n\ntype MessageIds =\n  | typeof onFunctionExplicitReturnType\n  | typeof onFunctionExplicitReturnTypeSuggest;\ntype Options = readonly [];\n\nexport default createRule<Options, MessageIds>({\n  name: path.parse(__filename).name,\n  meta: {\n    type: 'suggestion',\n    hasSuggestions: true,\n    docs: {\n      description: '`On` function should have an explicit return type.',\n      ngrxModule: 'store',\n    },\n    schema: [],\n    messages: {\n      [onFunctionExplicitReturnType]:\n        '`On` functions should have an explicit return type when using arrow functions: `on(action, (state): State => {}`.',\n      [onFunctionExplicitReturnTypeSuggest]:\n        'Add the explicit return type `State` (if the interface/type is named differently you need to manually correct the return type).',\n    },\n  },\n  defaultOptions: [],\n  create: (context) => {\n    return {\n      [onFunctionWithoutType](node: TSESTree.ArrowFunctionExpression) {\n        context.report({\n          node,\n          messageId: onFunctionExplicitReturnType,\n          suggest: [\n            {\n              messageId: onFunctionExplicitReturnTypeSuggest,\n              fix: (fixer) => getFixes(node, context.sourceCode, fixer),\n            },\n          ],\n        });\n      },\n    };\n  },\n});\n\nfunction getFixes(\n  node: TSESTree.ArrowFunctionExpression,\n  sourceCode: Readonly<TSESLint.SourceCode>,\n  fixer: TSESLint.RuleFixer\n) {\n  const { params } = node;\n\n  if (params.length === 0) {\n    const [, closingParen] = sourceCode.getTokens(node);\n    return fixer.insertTextAfter(closingParen, ': State');\n  }\n\n  const [firstParam] = params;\n  const lastParam = getLast(params);\n  const previousToken = sourceCode.getTokenBefore(firstParam);\n  const isParenthesized =\n    previousToken && ASTUtils.isOpeningParenToken(previousToken);\n\n  if (isParenthesized) {\n    const nextToken = sourceCode.getTokenAfter(lastParam);\n    return fixer.insertTextAfter(nextToken ?? lastParam, ': State');\n  }\n\n  return [\n    fixer.insertTextBefore(firstParam, '('),\n    fixer.insertTextAfter(lastParam, '): State'),\n  ] as const;\n}\n"]}