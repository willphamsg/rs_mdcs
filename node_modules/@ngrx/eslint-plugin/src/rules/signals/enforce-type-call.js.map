{"version":3,"file":"enforce-type-call.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/rules/signals/enforce-type-call.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2CAA6B;AAC7B,qDAAgD;AAChD,uCAA6D;AAEhD,QAAA,eAAe,GAAG,iBAAiB,CAAC;AAKjD,kBAAe,IAAA,yBAAU,EAAsB;IAC7C,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,IAAI;IACjC,IAAI,EAAE;QACJ,IAAI,EAAE,SAAS;QACf,IAAI,EAAE;YACJ,WAAW,EAAE,qCAAqC;YAClD,UAAU,EAAE,SAAS;SACtB;QACD,OAAO,EAAE,MAAM;QACf,MAAM,EAAE,EAAE;QACV,QAAQ,EAAE;YACR,CAAC,uBAAe,CAAC,EAAE,yCAAyC;SAC7D;KACF;IACD,cAAc,EAAE,EAAE;IAClB,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE;QAClB,yFAAyF;QACzF,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;QAEpC,OAAO;YACL,CAAC,uFAAuF,CAAC,CACvF,IAA8B;gBAE9B,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACjC,CAAC;YAED,yBAAyB,CAAC,IAAwC;gBAChE,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;gBACnC,IACE,IAAA,oBAAY,EAAC,UAAU,CAAC;oBACxB,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC;oBAC9B,CAAC,IAAA,wBAAgB,EAAC,IAAI,CAAC,MAAM,CAAC,EAC9B,CAAC;oBACD,OAAO,CAAC,MAAM,CAAC;wBACb,IAAI,EAAE,UAAU;wBAChB,SAAS,EAAE,uBAAe;wBAC1B,IAAI,EAAE,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE;wBAC/B,GAAG,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC;qBAClD,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;SACF,CAAC;IACJ,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { type TSESTree } from '@typescript-eslint/utils';\nimport * as path from 'path';\nimport { createRule } from '../../rule-creator';\nimport { isCallExpression, isIdentifier } from '../../utils';\n\nexport const enforceTypeCall = 'enforceTypeCall';\n\ntype MessageIds = typeof enforceTypeCall;\ntype Options = readonly [];\n\nexport default createRule<Options, MessageIds>({\n  name: path.parse(__filename).name,\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'The `type` function must be called.',\n      ngrxModule: 'signals',\n    },\n    fixable: 'code',\n    schema: [],\n    messages: {\n      [enforceTypeCall]: 'The `{{name}}` function must be called.',\n    },\n  },\n  defaultOptions: [],\n  create: (context) => {\n    // It's possible that we have multiple type import aliases, so we need to track them all.\n    const typeNames = new Set<string>();\n\n    return {\n      [`ImportDeclaration[source.value='@ngrx/signals'] ImportSpecifier[imported.name='type']`](\n        node: TSESTree.ImportSpecifier\n      ) {\n        typeNames.add(node.local.name);\n      },\n\n      TSInstantiationExpression(node: TSESTree.TSInstantiationExpression) {\n        const expression = node.expression;\n        if (\n          isIdentifier(expression) &&\n          typeNames.has(expression.name) &&\n          !isCallExpression(node.parent)\n        ) {\n          context.report({\n            node: expression,\n            messageId: enforceTypeCall,\n            data: { name: expression.name },\n            fix: (fixer) => fixer.insertTextAfter(node, '()'),\n          });\n        }\n      },\n    };\n  },\n});\n"]}