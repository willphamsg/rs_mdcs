{"version":3,"file":"avoid-cyclic-effects.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/rules/effects/avoid-cyclic-effects.ts"],"names":[],"mappings":"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","sourcesContent":["import { ESLintUtils, type TSESTree } from '@typescript-eslint/utils';\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport { createRule } from '../../rule-creator';\nimport {\n  asPattern,\n  createEffectExpression,\n  getNgRxEffectActions,\n  isCallExpression,\n  isIdentifier,\n  isTypeReference,\n} from '../../utils';\n\nexport const messageId = 'avoidCyclicEffects';\n\ntype MessageIds = typeof messageId;\ntype Options = readonly [];\n\n// This rule is a modified version (to support dispatch: false) from the eslint-plugin-rxjs plugin.\n// The original implementation can be found at https://github.com/cartant/eslint-plugin-rxjs/blob/main/source/rules/no-cyclic-action.ts\n// Thank you Nicholas Jamieson (@cartant).\n\nexport default createRule<Options, MessageIds>({\n  name: path.parse(__filename).name,\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Avoid `Effect` that re-emit filtered actions.',\n      ngrxModule: 'effects',\n      requiresTypeChecking: true,\n    },\n    schema: [],\n    messages: {\n      [messageId]: '`Effect` that re-emit filtered actions are forbidden.',\n    },\n  },\n  defaultOptions: [],\n  create: (context) => {\n    const { identifiers = [] } = getNgRxEffectActions(context);\n    const actionsNames = identifiers.length > 0 ? asPattern(identifiers) : null;\n\n    if (!actionsNames) {\n      return {};\n    }\n\n    const services = ESLintUtils.getParserServices(context);\n    const typeChecker = services.program.getTypeChecker();\n\n    function checkNode(pipeCallExpression: TSESTree.CallExpression) {\n      const operatorCallExpression = pipeCallExpression.arguments.find(\n        (arg) =>\n          isCallExpression(arg) &&\n          isIdentifier(arg.callee) &&\n          arg.callee.name === 'ofType'\n      );\n      if (!operatorCallExpression) {\n        return;\n      }\n      const operatorType = services.getTypeAtLocation(operatorCallExpression);\n      const [signature] = typeChecker.getSignaturesOfType(\n        operatorType,\n        ts.SignatureKind.Call\n      );\n\n      if (!signature) {\n        return;\n      }\n      const operatorReturnType =\n        typeChecker.getReturnTypeOfSignature(signature);\n      if (!isTypeReference(operatorReturnType)) {\n        return;\n      }\n      const [operatorElementType] =\n        typeChecker.getTypeArguments(operatorReturnType);\n      if (!operatorElementType) {\n        return;\n      }\n\n      const pipeType = services.getTypeAtLocation(pipeCallExpression);\n      if (!isTypeReference(pipeType)) {\n        return;\n      }\n      const [pipeElementType] = typeChecker.getTypeArguments(pipeType);\n      if (!pipeElementType) {\n        return;\n      }\n\n      const operatorActionTypes = getActionTypes(operatorElementType);\n      const pipeActionTypes = getActionTypes(pipeElementType);\n\n      for (const actionType of operatorActionTypes) {\n        if (pipeActionTypes.includes(actionType)) {\n          context.report({\n            node: pipeCallExpression.callee,\n            messageId,\n          });\n          return;\n        }\n      }\n    }\n\n    function getActionType(symbol: ts.Symbol): ts.Type | null {\n      const { valueDeclaration } = symbol;\n\n      if (!valueDeclaration) {\n        return null;\n      }\n\n      if (valueDeclaration.kind === ts.SyntaxKind.PropertyDeclaration) {\n        const { parent } = symbol as typeof symbol & { parent: ts.Symbol };\n        return parent.valueDeclaration\n          ? typeChecker.getTypeOfSymbolAtLocation(\n              parent,\n              parent.valueDeclaration\n            )\n          : null;\n      }\n\n      return typeChecker.getTypeOfSymbolAtLocation(symbol, valueDeclaration);\n    }\n\n    function getActionTypes(type: ts.Type): string[] {\n      if (type.isUnion()) {\n        const memberActionTypes: string[] = [];\n        for (const memberType of type.types) {\n          memberActionTypes.push(...getActionTypes(memberType));\n        }\n        return memberActionTypes;\n      }\n\n      const symbol = typeChecker.getPropertyOfType(type, 'type');\n\n      if (!symbol) {\n        return [];\n      }\n\n      const actionType = getActionType(symbol);\n\n      if (!actionType) {\n        return [];\n      }\n\n      // TODO: support \"dynamic\" types\n      // e.g. const genericFoo = createAction(`${subject} FOO`); (resolves to 'string')\n      if (typeChecker.typeToString(actionType) === 'string') {\n        return [];\n      }\n      return [typeChecker.typeToString(actionType)];\n    }\n\n    let firstPipe = true;\n    return {\n      [`${createEffectExpression}:not([arguments.1]:has(Property[key.name='dispatch'][value.value=false])) CallExpression[callee.property.name='pipe'][callee.object.property.name=${actionsNames}]`](\n        node\n      ) {\n        if (firstPipe) {\n          checkNode(node);\n          firstPipe = false;\n          return;\n        }\n      },\n\n      [`${createEffectExpression}:not([arguments.1]:has(Property[key.name='dispatch'][value.value=false])) CallExpression[callee.property.name='pipe']:exit`]() {\n        firstPipe = true;\n      },\n    };\n  },\n});\n"]}